<style>
h1{white-space:nowrap;margin:0 30 10 30;font-size:13pt}
.s{text-align:center}
.i{cursor:pointer;position:absolute;padding:5 10}
.br{border-radius:20px}
</style>
<div style="
pointer-events:none;
height:40vh;
backdrop-filter:blur(20px) hue-rotate(580deg);
position:fixed;
z-index:100;
top:60vh;
left:0;
mask-image:linear-gradient(transparent 0%, black 100%);
-webkit-mask-image:linear-gradient(transparent 0%, black 100%);
width:100vw;
"></div>
<div style=display:flex;height:100vh;overflow:hidden;background-color:black; id=container>
<canvas id=testCanvas></canvas>
<input id=focusTarget style=width:0px/>
<div id=f-ct style=color:white;height:100%;overflow:hidden;font-family:sans-serif>
    <div id=i class="br tr" style="background-color:white;color:black;min-width:220;min-height:72;opacity:1;max-width:500;position:absolute;top:0;left:0;outline:1px solid rgba(0,0,0,0.5);box-shadow:2px 2px 10px 1px rgba(0,0,0,0.5);margin:1em;padding:0.5em 0.5em 2em 0.5em">
        <div id=h class="i br" style=right:0;top:0;margin:2>&#10006;</div>
        <h1 class=s>Smart Avatars</h1>
        <div id="k" class="tr" style="right:0;top:36;position:absolute;display:flex;flex-direction:column"><p class="in">🡹w</p><p class="in">🡸a🡻s🡺d&nbsp;</p><p class="in">📜🔍</p></div>
    </div>
</div>
</div>
<canvas id=c style=display:none></canvas>
<script>  
// Smart Avatars
let gID = 'getElementById';
let gA = 'getAttribute';
let d=document;
let tcan = d[gID]("testCanvas");
let econt = d[gID]("container")
let sat = 'setAttribute';
let nft = window.cardano.nft;
let go = nft.getFileObject;
let tw = createjs.Tween.get;
let gS = (s,i)=>new createjs.Sprite(s,i);
let gP = (p)=>new createjs.SpriteSheet(p);
tcan[sat]('width',econt.getBoundingClientRect().width);
tcan[sat]('height',econt.getBoundingClientRect().height);
let AEL = 'addEventListener';
let children = [];
var distanceStep = 1;
var spriteScale=1+Math.pow(distanceStep,2)
var dummy = {step:1};
var spriteX=((parseInt(tcan[gA]('width'))-64*Math.pow(distanceStep,2))/2)
var spriteY=((parseInt(tcan[gA]('height'))-64*Math.pow(distanceStep,2))/2)
var eAlpha = 1, wAlpha = sAlpha = nAlpha = 0;
var direction='E';
var cont = new createjs.Container();
let sprites={S:{},N:{},W:{},E:{}};
let e = (s,a)=> {
    for (let c in s[a]) { 
            cont.removeChild(s[a][c]);
        }
    s[a]={};
}
let uS = async (files) => { 
    if (sprites.S) e(sprites,'S');
    if (sprites.N) e(sprites,'N');
    if (sprites.W) e(sprites,'W');
    if (sprites.E) e(sprites,'E');
    for (let c of ['body','head','bangs','pants','shirt','jacket','trim','gloves','shoes']) { 
    if (!files[c]) continue;
    var spriteSheet = gP({"animations":files[c].animations,"frames":files[c].frames,"images":[files[c].src]});
    var aN = gS(spriteSheet, "walking-north");
    var aS = gS(spriteSheet, "walking-south");
    var aW = gS(spriteSheet, "walking-west");
    var aE = gS(spriteSheet, "walking-east");
    aS.framerate=aN.framerate=aW.framerate=aE.framerate=6;
    aN.alpha=aS.alpha=aW.alpha=wAlpha;
    aE.alpha=eAlpha
    if (!sprites.S[c]) sprites.S[c]=aS
    if (!sprites.N[c]) sprites.N[c]=aN;
    if (!sprites.W[c]) sprites.W[c]=aW;
    if (!sprites.E[c]) sprites.E[c]=aE;
    cont.addChild(aS);
    cont.addChild(aN);
    cont.addChild(aW);
    cont.addChild(aE);
    }
}
const Fo=(s,a) => { 
    for (let c in s[a]) { 
        tw(s[a][c]).to({alpha:0},100);
    }            
}
d.onkeyup=(e)=>{
    let tdir = direction;
    let targetStep;
    switch(e.key.toUpperCase()) { 
        case 'A':
            direction='W';
            targetStep = dummy.step-2;
            if (targetStep>=0) targetStep=-2;
            tw(dummy).to({step:targetStep},250)[AEL]("change",(e) => { });
            wAlpha=1;
            for (let c in sprites.W) { 
                tw(sprites.W[c]).to({alpha:1, framerate: Math.abs(targetStep)*3},100)
            }
            break;
        case 'S':
            direction='S';
            distanceStep+=0.25;
            tw(dummy).to({step:0},1000)[AEL]("change",(e) => { });
            tw(cont).to({scale: 1+Math.pow(distanceStep,2),x:((parseInt(tcan[gA]('width'))-64*Math.pow(distanceStep,2))/2)},700)[AEL]("change",(e)=> { 
                spriteScale=e.target.target.scaleX;
                spriteX=e.target.target.x;
            });
            sAlpha=1;
            for (let c in sprites.S) { 
                tw(sprites.S[c]).to({alpha:1},100)
            }
            break;
        case 'D':
            direction='E';
            targetStep = dummy.step+2;
            if (targetStep <= 0) targetStep=2
            tw(dummy).to({step:targetStep},250)[AEL]
            eAlpha=1;
            for (let c in sprites.E) { 
                tw(sprites.E[c]).to({alpha:1, framerate: Math.abs(targetStep)*3},100)
            }
            break;
        case 'W':
            direction='N';
            distanceStep-=0.25;
            if (distanceStep<0) distanceStep=0;
            tw(dummy).to({step:0},1000)[AEL]("change",(e) => { });
            tw(cont).to({scale: 1+Math.pow(distanceStep,2),x:((parseInt(tcan[gA]('width'))-64*Math.pow(distanceStep,2))/2)},700)[AEL]("change",(e)=> { 
                spriteScale=e.target.target.scaleX;
                spriteX=e.target.target.x;
            });
            nAlpha=1;
            for (let c in sprites.N) { 
                tw(sprites.N[c]).to({alpha:1},100);
            }
        break;
        default:
            return;
    }
    if (tdir==direction) return;
    switch (tdir) { 
        case 'E':
            eAlpha=0;
            Fo(sprites,'E');
            break;
        case 'W':
            wAlpha=0;
            Fo(sprites,'W');
            break;
        case 'N':
            nAlpha=0;
            Fo(sprites,'N');
            break;
        case 'S':
            sAlpha=0;
            Fo(sprites,'S');
            break;
        default:
            return;
    }
}
tcan.onclick=()=>{
    d[gID]("focusTarget").focus();
}
var stage = new createjs.Stage(tcan);
    let ret = { files: {}, tokens: [] ,images:[]};
    let getImagesAmdTokens = () => { 
        let pid = '420acf8d7151fb73a556975cad1a60bf13e91d417be084fe87ef100d';
        go('walking',pid+'f09fa78df09fa79f').then((i) =>{ 
            ret.files.body = i;
            uS(ret.files);
        })
        go('walking',pid+'f09f9287e2808de29980efb88fe29982efb88f62616e67735f62756e').then((i)=>{
            ret.files.bangs = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa4af616c69656e').then((i)=> { 
            ret.files.head = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa6b5e29982efb88f70616e74732070696e6b').then((i)=>{
            ret.files.pants = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa6b6e29982efb88f6768696c6c696573206f72616e').then((i)=>{
            ret.files.shoes = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa7986a61636b6574207472696d3134').then((i)=>{
            ret.files.trim = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa798e29982efb88f636c6f74686573206c6f6e3136').then((i)=>{ 
            ret.files.shirt = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa798e29982efb88f6a61636b65742066726f6334').then((i)=>{
            ret.files.jacket = i;
            uS(ret.files);
        })
        go('walking',pid+'f09fa7a4e29982efb88f626c7565').then((i)=>{
            ret.files.gloves = i;
            uS(ret.files);
        })
    }
    getImagesAmdTokens();
    uS(ret.files);
    d[gID]("container").focus();
let simplex = new SimplexNoise();
let canvas = d[gID]('c');
canvas[sat]('width',256);
canvas[sat]('height',256);
let ctx = canvas.getContext('2d');
let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
let data = imageData.data;
w = stage.canvas.width;
h = stage.canvas.height;
let t = 0;
ground = new createjs.Shape();
ground.graphics.beginBitmapFill(canvas).drawRect(0, 0, w + canvas.width*2, canvas.height);
ground.tileW = canvas.width;
ground.y = h/2;
ground.x = 0-canvas.width*2;
ground.scaleX =1;
ground.scaleY = (stage.canvas.height/2)/canvas.height;
ground.cache(0, 0, w + canvas.width*2, canvas.height);
cont.x = spriteX;
cont.y = spriteY;
cont.scale = spriteScale;
stage.addChild(ground);
stage.addChild(cont);
createjs.Ticker.timingMode = createjs.Ticker.RAF;
createjs.Ticker[AEL]("tick", stage);
createjs.Ticker[AEL]("tick", drawPlasma);
function drawPlasma(){ 
for (let x = 0; x < canvas.width; x++) {
    for (let y = 0; y < canvas.height; y++) {
    let multiplier = (y/(canvas.width*4));
    let r = simplex.noise3D((x*multiplier) / 1, y / 1, t/128) * 0.5 + 0.5;
        let g = simplex.noise3D((x*multiplier) / 8, y / 8, t/128) * 0.5 + 0.5;
        let amount = y/64
        let xPos = Math.round((x-amount*t))
    xPos = canvas.width + xPos%canvas.width         
    xPos=xPos%canvas.width;
        data[(xPos + y * canvas.width) * 4 + 0] = r * 255;
        data[(xPos + y * canvas.width) * 4 + 1] = g * 100;
        data[(xPos + y * canvas.width) * 4 + 2] = g*200;
        data[(xPos + y * canvas.width) * 4 + 3] = 255* (y/(canvas.height/2));
    }
}
ground.x=(0-canvas.width )+ (ground.x-dummy.step)%(ground.tileW)
t+=dummy.step;
ctx.putImageData(imageData, 0, 0);
ground.graphics.beginFill('rgba(0,0,0,0)').drawRect(0, 0, w + canvas.width*2, canvas.height);
ground.graphics.clear();
ground.graphics.beginBitmapFill(canvas).drawRect(0, 0, w + canvas.width*2, canvas.height);
ground.updateCache();
}
drawPlasma();
</script>