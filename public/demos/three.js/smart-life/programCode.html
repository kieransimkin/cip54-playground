<div id="scene-container" style="height:100%;overflow:hidden;font-family:sans-serif;"/>
<script type="x-shader/x-vertex" id="vertexShader">

    varying vec3 vWorldPosition;

    void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

</script>

<script type="x-shader/x-fragment" id="fragmentShader">

    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;

    varying vec3 vWorldPosition;

    void main() {

        float h = normalize( vWorldPosition + offset ).y;
        gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h, 0.0 ), exponent ), 0.0 ) ), 1.0 );

    }

</script>
<script>
let f=()=>{
    // https://mathworld.wolfram.com/ElementaryCellularAutomaton.html
    // From Wolfram's book "A new kind of science"
    let container=document.querySelector('#scene-container');
    if (!window?.cardano||!window?.cardano?.nft||typeof THREE=='undefined') { 
        container.innerHTML="CIP54 not supported. For a marketplace with CIP54 support, try Plutus.art"
        return;
    }
    let output;let ruleNum=82;let gens=512;let rot=0;let width=gens*2;let prevTs=null;let start;let lag=false;let group;let SPEED=0.02;let T=THREE;
    let scene=new T.Scene();
    let geometry=new T.BoxGeometry(1,1,1);
    let camera=new T.PerspectiveCamera(30,container.clientWidth/container.clientHeight,0.1,width*8);
    let material=new T.MeshPhongMaterial( { ambient: 0xffffff, color: 0xffffff, specular: 0x050505, perPixel: true } );
    let renderer=new T.WebGLRenderer({ antialias: true, alpha: false, clearColor: 0xfafafa, clearAlpha: 1 });
    scene.background=new T.Color('black');
    renderer.setSize(container.clientWidth,container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.gammaInput = true;
	renderer.gammaOutput = true;
    renderer.physicallyBasedShading = true;
	renderer.shadowMapEnabled = true;
	renderer.shadowMapCullFrontFaces = false;
    container.append(renderer.domElement);
    camera.position.set(0,200,width*2);
    let hemiLight=new T.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
	hemiLight.color=new T.Color("blue");
	hemiLight.groundColor=new T.Color("white");
	hemiLight.position.set( 0, 500, 0 );
	scene.add( hemiLight );

				//
    scene.fog = new T.Fog( 0xffffff, 1, 5000 );
	scene.fog.color = new T.Color("yellow");

	let dirLight = new T.DirectionalLight( 0xffffff, 1 );
	dirLight.color = new T.Color("brown");
	dirLight.position.set( -1, 1.75, 1 );
	dirLight.position.multiplyScalar( 50 );
	scene.add( dirLight );

	dirLight.castShadow = true;

	dirLight.shadowMapWidth = 2048;
	dirLight.shadowMapHeight = 2048;
/*
	var d = 50;

	dirLight.shadowCameraLeft = -d;
	dirLight.shadowCameraRight = d;
	dirLight.shadowCameraTop = d;
	dirLight.shadowCameraBottom = -d;

	dirLight.shadowCameraFar = 3500;
	dirLight.shadowBias = -0.0001;
	dirLight.shadowDarkness = 0.35;
    */
				//dirLight.shadowCameraVisible = true;

				// GROUND

				var groundGeo = new T.PlaneGeometry( 10000, 10000 );
				var groundMat = new T.MeshPhongMaterial( { ambient: 0xffffff, color: 0xffffff, specular: 0x050505, perPixel: true } );
				groundMat.color = new T.Color("yellow");

				var ground = new T.Mesh( groundGeo, groundMat );
				ground.rotation.x = -Math.PI/2;
				ground.position.y = -33;
				scene.add( ground );

				ground.receiveShadow = true;

				// SKYDOME

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor: 	 { type: "c", value: new T.Color( 0x0077ff ) },
					bottomColor: { type: "c", value: new T.Color( 0xffffff ) },
					offset:		 { type: "f", value: 33 },
					exponent:	 { type: "f", value: 0.6 }
				}
				uniforms.topColor.value.copy( hemiLight.color );

				//scene.fog.color.copy( uniforms.bottomColor.value );

				var skyGeo = new T.SphereGeometry( 4000, 32, 15 );
				var skyMat = new T.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: T.BackSide } );

				var sky = new T.Mesh( skyGeo, skyMat );
				scene.add( sky );


    // My implementation of the cellular automation:
    function fillOutput() { 
        output = [];
        for (let y=0;y<gens-1;y++) { 
            let row=new Int8Array(width);
            let prevRow;
            if (y==0) prevRow=getSeedRow(); else prevRow=output[y];
            for (let x=0;x<width;x++) { 
                let p1=p3=0;
                let p2=prevRow[x];
                if (x>0) p1=prevRow[x-1];
                if (x<width-1) p3=prevRow[x+1];
                row[x]=getCell(p1,p2,p3);
            }
            if (y==0) output.push(prevRow);
            output.push(row);
        }
    }
    function getSeedRow() { 
        let row=new Int8Array(width);
        row[Math.round(width/2)]=1;
        return row;
    }
    function isBitSet(num,i) {
        return num&(1<<i)
    }
    function getCell(p1,p2,p3) { 
        let p=0;
        if (p1==1) p=p|(1<<2);
        if (p2==1) p=p|(1<<1);
        if (p3==1) p=p|(1<<0);
        if (isBitSet(ruleNum,p)) return 1; 
        return 0;
    }
    /* End of cellular automation */ 

    /**
     * This section generates the 3d scene from the cellular automation output
     */
    function createScene() { 
        camera.position.set(0,200,width*2);
        if (group) scene.remove(group);
        group=new T.Group();
        group.position.set(0,(-150)-(0-gens),0)
        
        for (y=0;y<gens;y++) { 
            for (x=0;x<width;x++) { 
                if (output[y][x]) { 
                    let cube=new T.Mesh(geometry,material);
                    cube.castShadow = true;
	                cube.receiveShadow = true;
                    cube.position.set(x-width/2,0-(y-gens/2),0);
                    group.add(cube);
                }
            }
        }
        scene.add(group);
    }
    function gen() { 
        start=prevTs;
        fillOutput();
        createScene(); 
    }
    function rotate(amount) {
        if (!group) return; if (isNaN(amount)) return;
        let r=group.rotation;
        rot-=(amount/33)*SPEED; 
        r.y=rot;
        //r.x=rot;
        //r.z=rot; 
    }
    document.onkeyup=checkKey;

    function checkKey(e) {
        e=e||window.event;
        let c=e.keyCode;
        if (c=='87') {
            gens+=10;
        } else if (c=='83') {
            gens-=10;
        } else if (c=='65') {
            ruleNum--;
        } else if (c=='68') {
            ruleNum++;
        }
        width=gens*2;
        gen();
    }

    // new
    document.resize=resize;
    function resize() {
        camera.aspect = container.clientWidth/container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth,container.clientHeight);
    }
    //
    

    function render(ts) {
        if (start===undefined) {
            start=ts;
        }
        let elapsed=ts-prevTs;
        prevTs=ts;
        if (elapsed>50&&gens>20&&ts-start>1000) { 
            if (lag) { 
                gens=Math.round(gens/2);
                width=gens*2;
                gen();
                lag=false;
            } else lag=true;
        } else lag=false;
        requestAnimationFrame(render);
        rotate(elapsed);
        renderer.render(scene,camera);
    }
    gen();
    render();
    renderer.render(scene,camera);
};f();
</script>
